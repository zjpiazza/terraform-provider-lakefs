// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_current_user

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func CurrentUserDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"user": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"creation_date": schema.Int64Attribute{
						Computed:            true,
						Description:         "Unix Epoch in seconds",
						MarkdownDescription: "Unix Epoch in seconds",
					},
					"email": schema.StringAttribute{
						Computed:            true,
						Description:         "The email address of the user. If API authentication is enabled, this field is mandatory and will be invited to login.\nIf API authentication is disabled, this field will be ignored. All current APIAuthenticators require the email to be \nlowercase and unique, although custom authenticators may not enforce this.\n",
						MarkdownDescription: "The email address of the user. If API authentication is enabled, this field is mandatory and will be invited to login.\nIf API authentication is disabled, this field will be ignored. All current APIAuthenticators require the email to be \nlowercase and unique, although custom authenticators may not enforce this.\n",
					},
					"friendly_name": schema.StringAttribute{
						Computed:            true,
						Description:         "A shorter name for the user than the id. Unlike id it does not identify the user (it\nmight not be unique). Used in some places in the UI.\n",
						MarkdownDescription: "A shorter name for the user than the id. Unlike id it does not identify the user (it\nmight not be unique). Used in some places in the UI.\n",
					},
					"id": schema.StringAttribute{
						Computed:            true,
						Description:         "A unique identifier for the user. Cannot be edited.",
						MarkdownDescription: "A unique identifier for the user. Cannot be edited.",
					},
				},
				CustomType: UserType{
					ObjectType: types.ObjectType{
						AttrTypes: UserValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
		},
	}
}

type CurrentUserModel struct {
	User UserValue `tfsdk:"user"`
}

var _ basetypes.ObjectTypable = UserType{}

type UserType struct {
	basetypes.ObjectType
}

func (t UserType) Equal(o attr.Type) bool {
	other, ok := o.(UserType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UserType) String() string {
	return "UserType"
}

func (t UserType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	creationDateAttribute, ok := attributes["creation_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_date is missing from object`)

		return nil, diags
	}

	creationDateVal, ok := creationDateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_date expected to be basetypes.Int64Value, was: %T`, creationDateAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	friendlyNameAttribute, ok := attributes["friendly_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`friendly_name is missing from object`)

		return nil, diags
	}

	friendlyNameVal, ok := friendlyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`friendly_name expected to be basetypes.StringValue, was: %T`, friendlyNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UserValue{
		CreationDate: creationDateVal,
		Email:        emailVal,
		FriendlyName: friendlyNameVal,
		Id:           idVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewUserValueNull() UserValue {
	return UserValue{
		state: attr.ValueStateNull,
	}
}

func NewUserValueUnknown() UserValue {
	return UserValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUserValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UserValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UserValue Attribute Value",
				"While creating a UserValue value, a missing attribute value was detected. "+
					"A UserValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UserValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UserValue Attribute Type",
				"While creating a UserValue value, an invalid attribute value was detected. "+
					"A UserValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UserValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UserValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UserValue Attribute Value",
				"While creating a UserValue value, an extra attribute value was detected. "+
					"A UserValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UserValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUserValueUnknown(), diags
	}

	creationDateAttribute, ok := attributes["creation_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_date is missing from object`)

		return NewUserValueUnknown(), diags
	}

	creationDateVal, ok := creationDateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_date expected to be basetypes.Int64Value, was: %T`, creationDateAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewUserValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	friendlyNameAttribute, ok := attributes["friendly_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`friendly_name is missing from object`)

		return NewUserValueUnknown(), diags
	}

	friendlyNameVal, ok := friendlyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`friendly_name expected to be basetypes.StringValue, was: %T`, friendlyNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewUserValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewUserValueUnknown(), diags
	}

	return UserValue{
		CreationDate: creationDateVal,
		Email:        emailVal,
		FriendlyName: friendlyNameVal,
		Id:           idVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewUserValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UserValue {
	object, diags := NewUserValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUserValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UserType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUserValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUserValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUserValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUserValueMust(UserValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UserType) ValueType(ctx context.Context) attr.Value {
	return UserValue{}
}

var _ basetypes.ObjectValuable = UserValue{}

type UserValue struct {
	CreationDate basetypes.Int64Value  `tfsdk:"creation_date"`
	Email        basetypes.StringValue `tfsdk:"email"`
	FriendlyName basetypes.StringValue `tfsdk:"friendly_name"`
	Id           basetypes.StringValue `tfsdk:"id"`
	state        attr.ValueState
}

func (v UserValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["creation_date"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["friendly_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CreationDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["creation_date"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.FriendlyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["friendly_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UserValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UserValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UserValue) String() string {
	return "UserValue"
}

func (v UserValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"creation_date": basetypes.Int64Type{},
		"email":         basetypes.StringType{},
		"friendly_name": basetypes.StringType{},
		"id":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"creation_date": v.CreationDate,
			"email":         v.Email,
			"friendly_name": v.FriendlyName,
			"id":            v.Id,
		})

	return objVal, diags
}

func (v UserValue) Equal(o attr.Value) bool {
	other, ok := o.(UserValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreationDate.Equal(other.CreationDate) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.FriendlyName.Equal(other.FriendlyName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v UserValue) Type(ctx context.Context) attr.Type {
	return UserType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UserValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"creation_date": basetypes.Int64Type{},
		"email":         basetypes.StringType{},
		"friendly_name": basetypes.StringType{},
		"id":            basetypes.StringType{},
	}
}
